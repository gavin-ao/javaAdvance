# GC算法的演进

​		各种不同的GC算法具体的参数差异、性能异同以及适用场景，已经有很多详细的资料。这里我不打算再把这些已有的资料再重新搜罗一遍，我想站在一个“如何解决一个问题”的角度，谈谈自己对于GC算法是如何演进到今天这个样子的一个看法。

### GC的目的

​		gc的最高目的是为了把程序员解放出来。不需要再像之前的程序员，要花费大量的时间和精力去处理内存的分配管理，当年评判一个程序员水平的高低，会不会操作指针，是不是对内存布局了然于胸是一个很重要的标准，当然，技术的细节与深度肯定是一种有追求的表现，那是作为一个程序员的自我修养，而如果从生产效率的角度来说，把时间与精力放在解决业务问题本身上才应该是重点。这就是gc诞生的背景。

​		从最早的引用计数，串行gc，并行gc，标记清除、标记复制等等，我们会发现gc的算法好像越来越复杂，这又是什么原因呢？

### 问题发生了改变

​		我们最初的目的无非是实现内存管理的自动化。就好像你要造一辆车，当我们造出了4个轮子，一个沙发加一个方向盘后，其实你已经有了一辆车，某种意义上，你造车的目的已经达到了。那么你会到此为止吗？答案当然是不，否则也不会出现现在街上跑的这么多形形色色的车。在gc算法上，道理也是一样的。

​		当我们发明了serial gc，我们发现，随之而来的是stw问题，在cpu都是单核，程序大多是client模式的时代，可能感受还不是特别明显，但是随着硬件的进步，我们的“容忍度”变低了，也就是更强调“用户感受”，serial gc可以满足我们内存自动管理的诉求，但是感受太不好了，它一旦开始工作，就跟死机差不多 --- 业务线程没法干事。怎么解决呢？第一个念头是，我能不能让它工作的更快一些，比如我垃圾回收的线程加多一点，变多线程，这就是ParNew之类的算法出现的原因。

​		我们写了好多java程序后，统计出一个规律，对象之间也是不平等的，有些对象能存活很长时间，有些对象new出来没多久就没人用了，而且越是存活时间长的对象，它继续活下去的可能性也就更大，基于这种现象，我们开始对堆内存进行更详细的划分，从最早的分为年轻代-老年代 --- 一种粒度很粗的划分方式，越分越细，Eden区，S0，S1，甚至后来把Class的信息专门存放为Meta区，到最近的，整个堆内存开始不用分代而是用分区的概念。其实都是为了解决让gc算法更加“平滑”的手段。

### 总结

​		从gc算法的演进，我们发现，gc算法发展到今天，其实并不是一开始就规划好了。而是随着问题不断的变化，解决问题的手段也在随之发生变化。

​		从关注问题能不能解决，到问题能不能解决好。从追求高吞吐量到同时追求短暂停时间甚至无暂停时间，这是不是也在告诉我们，软件工程中，要避免过度设计，要学会tradeoff。